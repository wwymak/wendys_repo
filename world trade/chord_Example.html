
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
    <link href="../css/bootstrap.min.css" type="text/css" rel="stylesheet"/>
    <link rel="stylesheet" type="text/css" href="../css/dc.css"/>
    <script src="../js/jquery-1.10.2.min.js" type="text/javascript"></script>
    <script src="../js/bootstrap.min.js"></script> 
    <script src="../js/d3.js" charset="utf-8"></script>
<style type="text/css">
text {
font-size: 10px;
}
path.chord {
fill-opacity: .80;
}
</style>
</head>
<body>
<div id="body">
<div id="footer">
d3.layout.chord
<div class="hint">mouseover groups to highlight</div>
</div>
</div>
<script type="text/javascript">
	var w = 1280,
	h = 800,
	r1 = h / 2,
	r0 = r1 - 80;
	var fill = d3.scale.category20c();
	
	var chord = d3.layout.chord()
	.padding(.04)
	.sortSubgroups(d3.descending)
	.sortChords(d3.descending);
	
	var arc = d3.svg.arc()
	.innerRadius(r0)
	.outerRadius(r0 + 20);
	
	var svg = d3.select("#body").append("svg:svg")
	.attr("width", w)
	.attr("height", h)
	.append("svg:g")
	.attr("transform", "translate(" + w / 2 + "," + h / 2 + ")");
	
	d3.json("flare-imports.json", function(imports) {
	var indexByName = {},
	nameByIndex = {},
	matrix = [],
	n = 0;
	self.names = [];
	// Returns the Flare package name for the given class name.
	function name(name) {
	return name.substring(0, name.lastIndexOf(".")).substring(6);
	}
	// Compute a unique index for each package name.
	imports.forEach(function(d) {
	d = name(d.name);
	if (!(d in indexByName)) {
	nameByIndex[n] = d;
	indexByName[d] = n++;
	names.push(d);
	}
	});
// Construct a square matrix counting package imports.
imports.forEach(function(d) {
var source = indexByName[name(d.name)],
row = matrix[source];
if (!row) {
row = matrix[source] = [];
for (var i = -1; ++i < n;) row[i] = 0;
}
d.imports.forEach(function(d) { row[indexByName[name(d)]]++; });
console.log(matrix);
});
chord.matrix(matrix);
var g = svg.selectAll("g.group")
.data(chord.groups)
.enter().append("svg:g")
.attr("class", "group")
.on("mouseover", fade(.02))
.on("mouseout", fade(.80));

g.append("svg:path")
	.style("stroke", function(d) { return fill(d.index); })
	.style("fill", function(d) { return fill(d.index); })
	.attr("d", arc);

g.append("svg:text")
.each(function(d) { d.angle = (d.startAngle + d.endAngle) / 2; })
.attr("dy", ".35em")
.attr("text-anchor", function(d) { return d.angle > Math.PI ? "end" : null; })
.attr("transform", function(d) {
return "rotate(" + (d.angle * 180 / Math.PI - 90) + ")"
+ "translate(" + (r0 + 26) + ")"
+ (d.angle > Math.PI ? "rotate(180)" : "");
})
.text(function(d) { return nameByIndex[d.index]; });

svg.selectAll("path.chord")
.data(chord.chords)
.enter().append("svg:path")
.attr("class", "chord")
.style("stroke", function(d) { return d3.rgb(fill(d.source.index)).darker(); })
.style("fill", function(d) { return fill(d.source.index); })
.attr("d", d3.svg.chord().radius(r0));
});
// Returns an event handler for fading a given chord group.
function fade(opacity) {
return function(d, i) {
svg.selectAll("path.chord")
.filter(function(d) { return d.source.index != i && d.target.index != i; })
.transition()
.style("stroke-opacity", opacity)
.style("fill-opacity", opacity);
};
}
</script>
</body>
